---
title: "Escala"
author: "Darren Norris"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Escala}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Apresentação
Todos os processos e padrões ecológicos têm uma dimensão temporal e espacial. Assim sendo, o conceito de <b>escala</b> não somente representar essas dimensões, mas também, ajudar nos apresentá-los de uma forma que facilite o entendimento sobre os processos e padrões sendo estudados.

É muito importante ficar claro para você o que é escala (e o que não é!) e qual a importância desse conceito na elaboração do desenho experimental de um estudo, na coleta de dados, nas análises e na tomada de decisão. Esse tutorial te ajudará nisso!

### Breve definação
O termo escala refere-se à dimensão ou domínio espaço-temporal de um processo ou padrão. Na ecologia da paisagem, a escala é frequentemente descrita por sua componentes: resolução e extensão. 

* Resolução:  menor unidade espacial de medida para um padrão ou processo.
* Extensão: descreve o comprimento ou tamanho de área sob investigação.

Resolução e extensão tendem a covariar – investigações com maior extensão tendem a ter resolução maiores também. Parte dessa covariância é prática: é difícil trabalhar em grandes extensões com dados coletados em tamanhos de resolução finos. No entanto, parte dessa covariância também é conceitual: muitas vezes em grandes extensões, podemos esperar que processos operando em resolução muito finos forneçam somente “ruído” e não dados/informações relevantes sobre os sistemas. Como  os desafios computacionais diminuíram e a disponibilidade de dados de alta resolução aumentou, a covariância entre resolução e extensão nas investigações diminuiu.

### Primeiro passos com uma raster
Uma raster é um matriz de valores com coordenados geográficos. Cada pixel de uma raster representa uma região geográfica, e o valor do pixel representa uma característica dessa região ([Dados raster](https://docs.qgis.org/2.8/pt_BR/docs/gentle_gis_introduction/raster_data.html)).

Em geral é necessário baixar alguns pacotes para que possamos fazer
as nossas análises.

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(terra)
library(sf)
library(mapview)
library(tmap)

```


Inicialmente iremos gerar uma raster representando uma paisagem bem simples, de 6 por 6 pixels.
Você já deve saber que pixel eh a unidade básica de uma imagem (lembra da camera do seu celular, 10Mb ou algo assim?!). Vocês devem ter
visto sobre pixels e resolução no mesmo de geoprocessamento. Aqui podemos tratar o pixel como a resolução. Vamos dizer que temos um pixel de 10 metros (res=10 no bloco de código), ou seja,
uma quadrado de 10 por 10m, sendo essa, a menor unidade mapeável (tambem tem ligação com escala cartográfica!).

```{r, echo=TRUE, message=FALSE, warning=FALSE, fig.width =4, fig.height = 2.5}
#Essa linha de comando gera a paisagem virtual (simulação)
pai_sim <- rast(ncols=6, nrows=6, 
                xmin=1, xmax=60, 
                ymin=1, ymax=60, 
                res=10) 
#E essa atribui valores ("values") para os pixels criados acima
values(pai_sim)<-1 
plot(pai_sim) #essa plota
text(pai_sim) #Essa coloca os valores dos pixels
```

Agora vamos olhar um exemplo do mundo real. Uma pequena amostra do Rio Araguari, perto de Porto Grande. O ponto central da raster é de longitude: -51.406312 latitude: 0.726236. O arquivo tem uma classificação da terra feito pela [MapBiomas](https://mapbiomas.org/), que produz mapeamento anual da cobertura e uso da terra no Brasil desde 1985.

Baixar arquivo com os dados (formato ".tif"), link: [https://github.com/darrennorris/gisdata/blob/master/inst/raster/amostra_mapbiomas_2020.tif](https://github.com/darrennorris/gisdata/blob/master/inst/raster/amostra_mapbiomas_2020.tif) .
Lembrando-se de salvar o arquivo ("amostra_mapbiomas_2020.tif")  em um local conhecido no seu computador. Para facilitar, os arquivos deve ficar no mesmo diretório do seu código (verifique com <code>getwd()</code>).

```{r eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
rin <- "C:/Users/user/Documents/Articles/gis_layers/gisdata/inst/raster/amostra_mapbiomas_2020.tif"
ramostra <- rast(rin)
```

Carregar o arquivo com o função <code>file.choose()</code>, que faz a busca para arquivos.
```{r eval=FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#
ramostra <- rast(file.choose())
```

Agora podemos verificar informcões sobre o raster (metadados) e 
plotar para verificar.

```{r, fig.width =4, fig.height = 2.5}
ramostra
plot(ramostra)
```

Isso nos mostra informações sobre escala espacial (resolução e extensão) e a sistema de coordenados (SIRGAS 2000 / UTM zone 22N (EPSG:31976)).
Além disso, o mapa mostra que tem três classes com valores de 3, 12 e 33. 

Lembrando, O objetivo principal não é de fazer mapas. Mas, a visualização dos dados é um passo importante para verificar e entender os padrões. Portanto, segue exemplo mostrando uma forma de viaualizar o arquivo de raster como mapa.

Para entender o que os valores representam no mundo real precisamos de uma referência (legenda). Para a MapBiomas Coleção 6, arquivo: [Cod_Class_legenda_Col6_MapBiomas_BR.pdf](https://mapbiomas-br-site.s3.amazonaws.com/downloads/Colecction%206/Cod_Class_legenda_Col6_MapBiomas_BR.pdf). Existe também arquivos para fazer as mapas com cores corretas em [QGIS](https://mapbiomas-br-site.s3.amazonaws.com/downloads/Colecction%206/MapBiomas_Col6_classes_colors.qml) ou [ArcGIS](https://mapbiomas-br-site.s3.amazonaws.com/downloads/Colecction%206/Legenda_Col6_MapBiomas.lyr).

Olhando a legenda ([Cod_Class_legenda_Col6_MapBiomas_BR.pdf](https://mapbiomas-br-site.s3.amazonaws.com/downloads/Colecction%206/Cod_Class_legenda_Col6_MapBiomas_BR.pdf)), sabemos que "3", "12" e "33" representem cobertura de "Formação Florestal", "Formação Campestre", e "Rio, Lago e Oceano". Então podemos fazer um mapa com mais informações.

Daqui pra frente vamos aproveitar uma forma mais elegante de apresentar mapas e gráficos. Isso seria atraves a função "ggplot" (pacote [ggplot2](https://ggplot2.tidyverse.org/)), que faz parte do "tidyverse". Mais exemplos no [R cookbook](http://www.cookbook-r.com/Graphs/) : http://www.cookbook-r.com/Graphs/ . 

E com mais exemplos de mapas e dados espaciais no R:
[sf e ggplot2](https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html) : https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html

[Capitulo 8](https://geocompr.robinlovelace.net/adv-map.html) no livro [Geocomputation with R](https://geocompr.robinlovelace.net/) : https://geocompr.robinlovelace.net/adv-map.html

Primeiramente precisamos incluir as informações relevantes da legenda.

```{r}
# legenda e cores na sequencia correta
classe_valor <- c(3, 12, 33)
classe_legenda <- c("Formação Florestal", 
                   "Formação Campestre", "Rio, Lago e Oceano")
classe_cores <- c("#006400", "#B8AF4F", "#0000FF") 
```

Agora podemos fazer o mapa com as classes e os cores seguindo o padrão recomendado pela MapBiomas.


```{r, dpi=300, fig.width =5, fig.height = 4, out.height=400, out.width=500, fig.cap="Paisagem simples com valores e classes determinadas de uso e cobertura da terra."}
# Passo necessario para mostrar os valores
ramostra_df <- as.data.frame(ramostra, xy = TRUE)

ggplot(ramostra_df, aes(x=x, y=y)) +
  geom_raster(aes(fill = factor(mapbiomas_2020))) +
  scale_fill_manual("classe", 
                      values = classe_cores, 
                    labels = classe_legenda) + 
  coord_equal() +
  geom_text(data = ramostra_df, aes(x = x, y = y, 
                label = mapbiomas_2020)) + 
  theme(legend.position="top") + 
  guides(fill=guide_legend(nrow=2,byrow=TRUE))

```

## Alterando a resolução
 
Alterando a resolução serve como exemplo mostrando como os passos/etapas/cálculos mude dependendo o tipo de 
dados. Ou seja, é preciso adotar metodologias diferentes para dados categóricos (por exemplo classificação de cobertura da terra) e dados contínuos  (por exemplo distância até rio).

Alterando a resolução às vezes seria necessário, por exemplo, quando preciso padronizar dados/imagens oriundos de fontes diferentes com resoluções diferentes e/ou para reduzir a complexidade da modelagem. Lembrando - em cada nível de resolução, são observáveis processos e padrões que não podem necessariamente ser inferidos daqueles abaixo ou acima.

Agora iremos degradar a resolução desses dados, ou seja, iremos alterar o tamanho dos pixels. Como exemplo, iremos juntar (agregar) 3 pixels em um único pixel. Como você acha que podemos fazer isso? Quais valores esse pixel que vai substituir os 3 originais deve ter? Existem diversas maneiras de se fazer isso, uma das formas é através da média.

```{r}
ramostra_media<-aggregate(ramostra, fact=3, fun="mean")
ramostra_media <- resample(ramostra, ramostra_media)
```

Visualizar. Os valores calculados pela função não fazem sentido para uma classificação categórica.
```{r, dpi=300, fig.width =5, fig.height = 4, out.height=400, out.width=500, fig.cap="Aggregação errado. Uso da média cria valores categóricos errados e impossíveis."}
# Tidy
as.data.frame(ramostra_media, xy = TRUE) %>% 
  mutate(mapbiomas_2020 = round(mapbiomas_2020,1)) -> ramostra_media_df
# Plot
ggplot(ramostra_media_df, aes(x=x, y=y)) +
  geom_raster(aes(fill = factor(mapbiomas_2020))) +
  scale_fill_discrete("valor") + 
  coord_equal() + 
  geom_text(data = ramostra_media_df, aes(x = x, y = y, 
                label = mapbiomas_2020)) 

```

Outra opção é utilizar o valor mais comum da área, o que é particularmente adequado quando temos um mapa categórico, como por exemplo mata/não-mata. Segue exemplo com o valor mais frequente (modal).
```{r}
ramostra_modal<-terra::aggregate(ramostra, fact=3, fun="modal")
ramostra_modal <- resample(ramostra, ramostra_modal, method="near")
```

Visualizar. Os valores calculados pela função são consistentes com o original e fazem sentido. 
```{r, dpi=300, fig.width =5, fig.height = 4, out.height=400, out.width=500, fig.cap="Aggregação pela mais frequente."}
# Tidy
ramostra_modal_df <- as.data.frame(ramostra_modal, xy = TRUE) 
# Plot
ggplot(ramostra_modal_df, aes(x=x, y=y)) +
  geom_raster(aes(fill = factor(mapbiomas_2020))) +
  scale_fill_discrete("valor") + 
  coord_equal() + 
  geom_text(data = ramostra_modal_df, aes(x = x, y = y, 
                label = mapbiomas_2020)) 

```

Em cada nível de resolução, são observáveis processos e padrões que não podem necessariamente ser inferidos daqueles abaixo ou acima. Aqui por exemplo, mudamos a proporção de cobertura florestal em nossa pequeno paisagem quando juntamos 3 pixels em um único (proporção modou de 3/72 para 1/9). Ou seja, com cada passo mudamos a representção do mundo.

```{r, echo=FALSE, message=FALSE, warning=FALSE, dpi=300, fig.width =9, fig.height = 5, out.height=350, out.width=650, fig.cap="Mudanças causadas pela agregação."}
bind_rows(as.polygons(ramostra, dissolve = FALSE) %>% 
  st_as_sf() %>% mutate(type = "original"), 
  as.polygons(ramostra_media, dissolve = FALSE) %>% 
     st_as_sf() %>% mutate(type = "media", 
                           mapbiomas_2020 = round(mapbiomas_2020,1)),
  as.polygons(ramostra_modal, dissolve = FALSE) %>% 
     st_as_sf() %>% mutate(type = "modal")) -> sf_grids

sf_grids %>% 
  ggplot() + 
  geom_sf(aes(fill = factor(mapbiomas_2020))) +
  scale_fill_discrete("valor") + 
  scale_x_continuous(breaks = c(-51.4075, -51.4065, -51.4055)) +
  #geom_text(aes(x = x, y = y, 
  #              label = mapbiomas_2020)) + 
  facet_wrap(~type) + 
  theme(legend.position="top") + 
  guides(fill=guide_legend(nrow=2,byrow=TRUE))

```

## Escala Espacial e Desenho Amostral
Dado o papel que a escala pode desempenhar em nossa compreensão dos padrões  e processos ecológicos, como escala ser considerada no desenho do estudo? Claramente, a resposta a esta pergunta irá variar
dependendo dos fenômenos de interesse, mas ecologistas e estatísticos têm forneceu algumas orientações importantes. As questões-chave incluem o tamanho da unidade de amostragem (resoloção), o tipo de
unidade de amostra e localizações da unidade de amostra, incluindo o espacamento entre as amostras (distância entre as amostras) e o tamanho da área de estudo.

Com a disponibilidade de imagens de satélite é possível responder questões importantes relacionadas ao desenho do estudo antes de qualquer trabalho de campo. Uma tecnica de geoprocessamento (bordas - [Buffers](https://docs.qgis.org/3.16/pt_BR/docs/gentle_gis_introduction/vector_spatial_analysis_buffers.html)) é um dos mais frequentemente adotados para quantificar escala espacial na ecologia da paisagem.    O objetivo é criar buffers circulares de diferentes extensões ao redor dos sitios de amostragem (pontos, pixels, manchas, transetos lineares etc). 

### 1.1) Obter e carregar dados (vectores)
```{r, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
meuSIG <- "C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\vector\\rivers.gpkg"
fs <- file.size(meuSIG)/(1024^2)
```


Baixar arquivo com os dados (formato "GPKG", tamanho `r round(fs,1)` MB). 

Link: [https://github.com/darrennorris/gisdata/blob/master/inst/vector/rivers.GPKG](https://github.com/darrennorris/gisdata/blob/master/inst/vector/rivers.GPKG) .
Lembrando-se de salvar o arquivo ("rivers.GPKG")  em um local conhecido no seu computador.

Agora avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo "rivers.GPKG": 
```{r echo=TRUE, eval=FALSE}
meuSIG <- file.choose()
```

Agora vamos olhar o que tem no arquivo. Existem camadas diferentes com pontos e linhas:
```{r }
sf::st_layers(meuSIG)
```

O código abaixo vai carregar os dados e criar o objeto "rsm".
Agora temos dados com: pontos cada 5 km ao longo os rios (rsm) e a 
linha central de rios ("rsl").
```{r }
rsm <- sf::st_read(meuSIG, layer = "midpoints")
rsl <- sf::st_read(meuSIG, layer = "centerline")
```



<P style="page-break-before: always">

### 1.2) Mapa com linha central e pontos de rios em trechos de 5km

```{r fig.width=7, fig.height=4}
ggplot(rsl) +
  geom_sf(aes(color=rio)) +
  geom_sf(data = rsm, shape=21, aes(fill=zone))
```

### 1.3) Interativo (funcione somente com internet) 
Mostrando agora com fundo de mapas "base" (OpenStreetMap/ESRI etc) 
```{r fig.width=5, fig.height=5, echo=FALSE, message=FALSE, warning=FALSE}

mapview(rsl, zcol = "rio") 

```

<P style="page-break-before: always">

### 1.4) Obter e carregar dados (raster)
```{r echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
meuSIGr <- "C:\\Users\\user\\Documents\\Articles\\gis_layers\\gisdata\\inst\\raster\\mapbiomas_AP_utm_rio\\utm_cover_AP_rio_2020.tif"
fs2 <- file.size(meuSIGr)/(1024^2)
```
Mais uma vez vamos aproveitar os dados de MapBiomas. 
Baixar arquivo raster com os dados (formato ".tif", tamanho `r round(fs2,1)` MB). 
Link: [https://github.com/darrennorris/gisdata/blob/master/inst/raster/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif](https://github.com/darrennorris/gisdata/blob/master/inst/raster/mapbiomas_AP_utm_rio/utm_cover_AP_rio_2020.tif) .
Lembrando-se de salvar o arquivo ("utm_cover_AP_rio_2020.tif") em um local conhecido no seu computador. Para facilitar, os arquivos deve ficar no mesmo diretório do seu código (verifique com <code>getwd()</code>).

Agora avisar R sobre onde ficar o arquivo. O código abaixo vai abrir uma nova janela, e você deve buscar e selecionar o arquivo "utm_cover_AP_rio_2020.tif": 
```{r echo=TRUE, eval=FALSE}
meuSIGr <- file.choose()
```

O código abaixo vai carregar os dados e criar o objeto "mapbiomas_2020". Para isso trabalhamos com o pacote [terra](https://CRAN.R-project.org/package=terra). O pacote tem varios funçoes para a análise e modelagem de dados geográficos.

```{r }
mapbiomas_2020 <- rast(meuSIGr)

```

O arquivo tem uma classificação da terra no ano 2020 feito pela [MapBiomas](https://mapbiomas.org/). Tmap (https://r-tmap.github.io/tmap-book/index.html)

```{r fig.width=7, fig.height=7}
# Passo necessario para agilizar o processamento
mapbiomas_2020_modal<-aggregate(mapbiomas_2020, fact=10, fun="modal")
tm_shape(mapbiomas_2020_modal) +
  tm_raster(title = "Classe", style = "cat", 
            palette = "Set3") + 
  tm_shape(rsl) + 
  tm_lines(col="blue") + 
  tm_shape(rsm) + 
  tm_dots(size = 0.4, col = "yellow")

```


## Análise Multiescala da Cobertura Florestal
